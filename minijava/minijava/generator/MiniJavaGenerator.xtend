/*
 * generated by Xtext 2.10.0
 */
package org.xtext.projects.minijava.generator

import com.google.inject.Inject
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.eclipse.xtext.naming.IQualifiedNameProvider
import org.xtext.projects.minijava.MiniJavaLib
import org.xtext.projects.minijava.MiniJavaModelUtil
import org.xtext.projects.minijava.miniJava.Assignment
import org.xtext.projects.minijava.miniJava.Block
import org.xtext.projects.minijava.miniJava.BoolConstant
import org.xtext.projects.minijava.miniJava.ClassDecl
import org.xtext.projects.minijava.miniJava.IfStatement
import org.xtext.projects.minijava.miniJava.IntConstant
import org.xtext.projects.minijava.miniJava.MemberSelection
import org.xtext.projects.minijava.miniJava.NewObject
import org.xtext.projects.minijava.miniJava.Null
import org.xtext.projects.minijava.miniJava.Parameter
import org.xtext.projects.minijava.miniJava.Goal
import org.xtext.projects.minijava.miniJava.Return
import org.xtext.projects.minijava.miniJava.Statement
import org.xtext.projects.minijava.miniJava.StringConstant
import org.xtext.projects.minijava.miniJava.Super
import org.xtext.projects.minijava.miniJava.SymbolRef
import org.xtext.projects.minijava.miniJava.This
import org.xtext.projects.minijava.miniJava.VarDecl
import org.xtext.projects.minijava.miniJava.Type
import org.xtext.projects.minijava.miniJava.CommonType
import org.xtext.projects.minijava.miniJava.Expression

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MiniJavaGenerator extends AbstractGenerator {

	@Inject extension IQualifiedNameProvider
	@Inject extension MiniJavaModelUtil

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val program = resource.allContents.toIterable.filter(Goal).head
		// an empty program is a valid MiniJava program
		if (program === null)
			return;
		// don't compile the classes of the MiniJava library
		if (program.name == "minijava.lang")
			return;
		for (miniJavaClass : program.classes) {
			fsa.generateFile(
				miniJavaClass.fullyQualifiedName.toString.replace(".", "/") + ".java",
				'''
					«IF program.name !== null»
						package «program.name»;
						
					«ENDIF»
					public class «miniJavaClass.name» «IF miniJavaClass.superclass !== null»extends «miniJavaClass.superclass.compileTypeReference» «ENDIF»{
						«FOR field : miniJavaClass.fields»
							«field.access» «field.type.compileTypeReference» «field.name»;
						«ENDFOR»
						«FOR method : miniJavaClass.methods»
							«method.access» «method.type.compileTypeReference» «method.name»(«method.params.map[compileParam].join(", ")») «compileBlock(method.body)»
						«ENDFOR»
					}
				'''
			)
		}
	}

	def compileTypeReference(Type t) {
		val typeName = (t as CommonType).typename
		val className = (t as CommonType).classname.fullyQualifiedName.toString
		if (typeName !== null) {
			switch (typeName) {
				case typeName == MiniJavaLib.LIB_STRING: "String"
				case typeName == MiniJavaLib.LIB_INTEGER: "Integer"
				case typeName == MiniJavaLib.LIB_BOOLEAN: "Boolean"
				case typeName == MiniJavaLib.LIB_OBJECT: "Object"
				default: typeName
			}
		} else if (className !== null) {
			switch (className) {
				case className == MiniJavaLib.LIB_STRING: "String"
				case className == MiniJavaLib.LIB_INTEGER: "Integer"
				case className == MiniJavaLib.LIB_BOOLEAN: "Boolean"
				case className == MiniJavaLib.LIB_OBJECT: "Object"
				default: className
			}
		}
	}

	def compileTypeReference(ClassDecl c) {
		val fqn = c.fullyQualifiedName.toString
		switch (fqn) {
			case fqn == MiniJavaLib.LIB_OBJECT: "Object"
			case fqn == MiniJavaLib.LIB_STRING: "String"
			case fqn == MiniJavaLib.LIB_INTEGER: "Integer"
			case fqn == MiniJavaLib.LIB_BOOLEAN: "Boolean"
			default: fqn
		}
	}

	def compileParam(Parameter p) {
		'''«p.type.compileTypeReference» «p.name»'''
	}

	def compileBlock(Block block) '''
		{
			«FOR s : block.statements»
				«compileStatement(s)»
			«ENDFOR»
		}
	'''

	def String compileStatement(Statement s) {

		switch (s) {
			VarDecl: '''«s.decltype.compileTypeReference» «s.name» = «s.expression.compileExpression»;'''
			Return:
				"return " + s.expression.compileExpression + ";"
			IfStatement: '''
				if («s.expression.compileExpression»)
					«s.thenBlock.compileBlock»
				«IF s.elseBlock !== null»
					else
						«s.elseBlock.compileBlock»
				«ENDIF»
			'''
			default:
				s.compileExpression + ";"
		}
	}

	def String compileExpression(Statement e) {
		switch (e) {
			StringConstant:
				'"' + e.value + '"'
			IntConstant:
				e.value.toString
			BoolConstant:
				e.value
			Null:
				"null"
			This:
				"this"
			Super:
				"super"
			SymbolRef:
				e.symbol.name
			NewObject:
				"new " + e.type.compileTypeReference + "()"
			Assignment: {
				e.left.compileExpression + " = " + e.right.compileExpression
			}
			MemberSelection: {
				e.receiver.compileExpression + "." + e.member.name + if (e.methodinvocation) {
					"(" + e.args.map[compileExpression].join(", ") + ")"
				} else {
					""
				}
			}
		}
	}
}
